/**
 * @fileOverview [PC/M] 공감하기 > 메인 컨트롤러 파일
 * @author moonseok.kim@navercorp.com(Naver)
 * @since 2016.01.12
 */

/**
 * 공감하기 컨트롤러
 *
 * @class reaction.Controller
 * @constructor
 * @requires reaction.Buttons
 * @requires reaction.Friends
 */
reaction.Controller = function (conf, messageSet) {
    this._conf = conf || reaction.conf();
    messageSet = messageSet || reaction.message;
    var message = this._selectMessage(messageSet, this._conf.language);

    this._reactionButtons = new reaction.Buttons(this._conf, message);
    this._reactionCaptcha = new reaction.Captcha(this._conf, message);

    // reaction.Friend 의존성 분리를 위한 코드 추가 (type에 따른 분류가 아닌 객체로 판단. 왜? 오류방지를 위해서.)
    this._reactionFriends = reaction.Friends ? new reaction.Friends(this._conf, message) : null;
    this._attachEvent();
};

/** @lends reaction.Controller.prototype */
reaction.Controller.prototype = {
    constructor: reaction.Controller,

    /**
     * 언어코드에 따라 스크립트에서 메시지셋을 선택한다.
     * 1) zh_hans & zh-hans 처럼 두 가지 모두 허용하는 경우, 2) 미리 정의된 메시지가 없는 경우를 처리한다.
     * default는 message.en 이다.
     *
     * @param messageSet
     * @param language
     * @returns {*}
     * @private
     */
    _selectMessage: function (messageSet, language) {
        var bothAllowLang = {
            "zh_hans": "zh-hans",
            "zh_hant": "zh-hant"
        };

        if (bothAllowLang[language]) {
            language = bothAllowLang[language];
        }

        return messageSet[language] || messageSet.en;
    },

    _attachEvent: function () {
        //클릭로그를 위한 핸들러
        var clicklogHandler = jQuery.proxy(function (event, params) {
            this._clicklog(event, params);
        }, this);

        //버튼 객체에 커스텀 이벤트 바인딩
        var $reactionButtons = jQuery(this._reactionButtons);
        $reactionButtons
            .on("clickReaction", clicklogHandler)
            .on("captchaReaction", jQuery.proxy(function (event, captchaInfos) {
                this._reactionCaptcha.load(captchaInfos);
            }, this));

        //captcha
        var $reactionCaptcha = jQuery(this._reactionCaptcha);
        $reactionCaptcha
            .on("requestPreviousReaction", jQuery.proxy(function () {
                //Captcha로 인해서 블로킹되었던 요청을 재전송한다.
                this._reactionButtons.requestPreviousReaction();
            }, this))
            .on("clearPreviousReaction", jQuery.proxy(function () {
                //captcha 임시 데이터 삭제.
                this._reactionButtons.clearPreviousReaction();
            }, this));

        if (this._reactionFriends) {
            $reactionButtons.on("successReaction", jQuery.proxy(function (event, params) {
                if (!params.isNeoid && params.friendsLayerId) {
                    if (params.isAdding) {
                        this._reactionFriends.show(params);
                    } else {
                        this._reactionFriends.hide(params);
                    }
                }
            }, this));

            //친구목록레이어에 커스텀 이벤트 바인딩
            jQuery(this._reactionFriends)
                .on("connectLineId", clicklogHandler)
                .on("closeLineIdConnectionWithCache", clicklogHandler)
                .on("closeLineIdConnection", clicklogHandler)
                .on("shareTimelineOnce", clicklogHandler)
                .on("shareTimelineAlways", clicklogHandler)
                .on("closeTimelineShareWithCache", clicklogHandler)
                .on("closeTimelineShare", clicklogHandler)
                .on("setTimelineShare", clicklogHandler)
                .on("launchApp", clicklogHandler);
        }
    },

    _detachEvent: function () {
        jQuery(this._reactionButtons).off();
        jQuery(this._reactionFriends).off();
    },

    _destroy: function () {
        this._detachEvent();
        this._reactionButtons._destroy();

        //@todo friends 타입은 제외
        //this._reactionFriends && this._reactionFriends._destroy();
    },

    // 로그 파싱 및 호출 함수
    _clicklog: function (customEvent, params) {
        var event = params.event,
            target = params.target,
            log = jQuery(target).attr("data-log"),
            parsedLog;

        if (!log) {
            return;
        }

        //공감하기 버튼인 경우
        if (customEvent.type === "clickReaction") {
            parsedLog = log.split("|");
            log = params.isAdding ? parsedLog[0] : parsedLog[1];
        }

        !!(log) && reaction.clicklog(target, log, event);
    },

    /**
     * 지정한 대상 내 reaction 버튼을 갱신한다.
     * <br>(파라미터로 갱신할 버튼을 직접 지정할 수 있으며, 지정하지 않을 경우 페이지 내 모든 버튼이 갱신 대상이 된다.)
     *
     * @method reaction.Controller#update
     * @param {Selector|jQuery|HTMLElement[]|HTMLElement} [context=document.body] 갱신할 버튼 앨리먼트 배열 or 갱신할 버튼을 감싸고 있는 상위 엘리먼트
     * @param {Boolean} [isAllRefresh=false] 이전에 갱신한 버튼을 다시 갱신할지 여부
     * @example
     * //문서 전체에서 새로 추가된 공감하기 버튼 세트만 갱신
     * reaction.instance.update();
     *
     * //문서 전체에서 모든 공감하기 버튼 세트를 강제 갱신
     * reaction.instance.update(null, true);reaction
     *
     * //Selector로 지정 예
     * reaction.instance.update("#content_wrapper"); //상위 엘리먼트를 지정
     * reaction.instance.update("._reactionModule"); //비튼을 직접 지정하여 갱신(Element or Collection 가능)
     *
     * //HTMLElement로 지정 예
     * reaction.instance.update(document.getElementById("content_wrapper")); //상위 엘리먼트 지정
     * reaction.instance.update(document.getElementsByClassName("._reactionModule")); //버튼을 직접 지정하여 갱신(Element or Collection 가능)
     *
     * //jQuery를 이용하여 지정 예
     * reaction.instance.update(jQuery("#content_wrapper")); ////상위 엘리먼트 지정
     * reaction.instance.update(jQuery("._reactionModule")); //버튼을 직접 지정하여 갱신(Element or Collection 가능)
     *
     * [참고]
     * data-loaded 를 강제로 0으로 바꿔서 다시 초기화하는 방법으로 우회할 수 있지만, update를 사용해서 갱신하는 것이 바람직하다.
     */
    update: function (context, isAllRefresh) {
        this._reactionButtons.update(context, isAllRefresh);
        return this;
    },

    /**
     * reaction 버튼에 의해 노출된 face 레이어를 숨긴다.
     *
     * @method reaction.Controller#hideLayers
     * @returns {Boolean} 레이어를 성공적으로 숨겼으면 true, 아니면 false
     * @example
     * // face 레이어를 숨김
     * reaction.instance.hideLayers();
     */
    hideLayers: function () {
        if (this._reactionButtons && typeof this._reactionButtons.hideLayers === "function") {
            return this._reactionButtons.hideLayers();
        }
        return false;
    }
};

// jshint ignore:start
// jscs:disable
/**
 * @fileOverview [PC/M] 공감하기 > 친구목록 모듈 > 마크업 템플릿
 * @author moonseok.kim@navercorp.com(Naver)
 * @since 2016.02.15
 */
// reaction.Friends = reaction.Friends || {};

/**
 * 친구목록(SNS연동/타임라인)에서 사용되는 템플릿 모음(micro-template 엔진 사용)
 *
 * @memberof reaction
 * @static
 * @example
 * reaction.templates.process(templateId, data)
 */
reaction.templates = function (messages) {
    var templates = {
        snsIdConnection: "<div class='u_likeit_wrap'><div class='u_linkage'>" +
            "<p class='u_txt'>" + messages.linkWithLineLayer.msgInfo + "</p>" +
            "<a href='#' class='u_btn_linkage _connectLineId' data-log='LYE.line'>" + messages.linkWithLineLayer.btnLink + "</a>" +
            "<div class='u_chk'><input type='checkbox' id='u_month_hide' checked='checked' class='_closeLineIdConnectionWithCache' data-log='LYE.never'><label for='u_month_hide' onclick='void(0)'>" + messages.common.chkboxDontShow + "</label><a href='#' class='u_btn_close _closeLineIdConnection' data-log='LYE.close'>" + messages.common.btnClose + "</a></div></div></div>",
        timelineShare: "<div class='u_likeit_wrap'><div class='u_sharing'>" +
            "<p class='u_txt'>" + messages.shareLayer.shareConfirm + "</p>" +
            "<div class='u_btn_area'><a href='#' class='u_btn_one _shareTimelineOnce' data-log='LSE.share'>" + messages.shareLayer.btnOnceShare + "</a><a href='#' class='u_btn_auto _shareTimelineAlways' data-log='LSE.auto'>" + messages.shareLayer.btnAutoShare + "</a></div>" +
            "<div class='u_chk'><input type='checkbox' id='u_month_hide' checked='checked' class='_closeTimelineShareWithCache' data-log='LSE.never'><label for='u_month_hide' onclick='void(0)'>" + messages.common.chkboxDontShow + "</label><a href='#' class='u_btn_close _closeTimelineShare' data-log='LSE.close'>" + messages.common.btnClose + "</a></div></div></div>",
        friendsListError: "<div class='u_likeit_wrap'><p class='u_error'>" + messages.friendsLayer.error + "</p><a href='#' class='u_btn_set _setTimelineShare' data-log='LIK.share'>" + messages.friendsLayer.btnShareSetting + "</a></div>",
        friendsListLoading: "<div class='u_likeit_wrap'><div class='u_loading'><p class='u_txt'><span class='u_ico_loading'></span>" + messages.friendsLayer.loading + "</p></div><a href='#' class='u_btn_set _setTimelineShare' data-log='LIK.share'>" + messages.friendsLayer.btnShareSetting + "</a></div>",
        friendsList: "<div class='u_likeit_wrap'><div class='u_friends'>" +
            "<div style='overflow: hidden; z-index: 0; position: relative; height: 36px;' class='_scrollview'>" +
            "<div class='_scroller'>" +
            "<ul class='u_list'>" +
            "<% for(var i=0, len=friends.length, friend; i < len; i++){ %>" +
            "<% friend = friends[i]; %>" +
            "<% isMine = (status !== 'FRIENDS' && status !== 'NONE' && i === 0); %>" +
            "<li class='u_thmb'>" +
            "<a href='#' class='_launchApp' <% if(!isMine){ %> data-mid='<%=friend.mid%>' <% } %> data-log='LIK.friends'>" +
            "<img src='<%=friend.smallPictureUrl%>' width='35' height='35' alt='<%=friend.displayName%>' onerror='this.onerror=null;this.src=\"https://ssl.pstatic.net/static/m/likeit/line_noimg.png\"'>" +
            "</a>" +
            "</li>" +
            "<% } %>" +
            "</ul>" +
            "</div>" +
            "</div>" +
            "<% if(status === 'ME'){ %>" +
            "<p class='u_dsc'>" + messages.friendsLayer.me + "</p>" +
            "<% }else if(status === 'ME_AND_FRIENDS'){ %>" +
            "<p class='u_dsc'>" + messages.friendsLayer.meAndFriends + "</p>" +
            "<% }else if(status == 'FRIENDS'){ %>" +
            "<p class='u_dsc'>" + messages.friendsLayer.friends + "</p>" +
            "<% } %>" +
            "<a href='#' class='u_btn_set _setTimelineShare' data-log=LIK.share''>" + messages.friendsLayer.btnShareSetting + "</a>" +
            "</div></div>",
        captchaLayer: "<div class='u_likeit_captcha' style='display:block'>" +
            "<strong class='u_likeit_blind'> " + messages.captcha.layer + "</strong>" +
            "<div class='u_likeit_captcha_dimmed'></div>" +
            "<div class='u_likeit_captcha_wrap'>" +
            "<h3 class='u_likeit_captcha_title'>" + messages.captcha.title + "</h3>" +
            "<p class='u_likeit_captcha_desc'>" + messages.captcha.desc + "</p>" +
            "<div class='u_likeit_captcha_img_area'>" +
            "<div class='u_likeit_captcha_img'>" +
            "<img src='<%=captchaImageUrl%>' width='300' height='99' alt='captcha'>" +
            "</div>" +
            "<a href='#refresh' class='u_likeit_captcha_refresh'>" + messages.captcha.refresh + "</a>" +
            "</div>" +
            "<div class='u_likeit_captcha_input_area'>" +
            "<input id='likeit_captcha_defense' class='u_likeit_captcha_input' type='text'>" +
            "<label for='likeit_captcha_defense' class='u_likeit_captcha_label'>" + messages.captcha.defense + "</label>" +
            "</div>" +
            "<a href='#submit' class='u_likeit_captcha_submit'>" + messages.captcha.submit + "</a>" +
            "<a href='#close' class='u_likeit_captcha_close'><span class='u_likeit_blind'>" + messages.captcha.close + "</span></a>" +
            "</div>" +
            "</div>",
        certificationLayer: "<div" +
            " class=\"u_likeit_popup_wrapper _likePopupModule\">\n" +
            "            <div class=\"u_likeit_popup\">\n" +
            "                <strong" +
            " class=\"u_likeit_popup_title\">" + messages.certification.title + "</strong>\n" +
            "                <p" +
            " class=\"u_likeit_popup_description\">" + messages.certification.desc + "</p>\n" +
            "                <a" +
            " class=\"u_likeit_popup_link_certification" +
            " _button\">" + messages.certification.btnLink + "</a>\n" +
            "                <button type=\"button\" class=\"u_likeit_popup_close\">\n" +
            "                    <span" +
            " class=\"u_likeit_blind\">" + messages.certification.btnClose + "</span>\n" +
            "                </button>\n" +
            "            </div>\n" +
            "        </div>",
    };

    //micro-template wrapper (MIT Licensed - http://ejohn.org/blog/javascript-micro-templating/)
    var cache = {};
    var tmpl = function tmpl(str, data) {
        // Figure out if we're getting a template, or if we need to
        // load the template - and be sure to cache the result.
        var fn = !/\W/.test(str) ?
            cache[str] = cache[str] ||
                tmpl(document.getElementById(str).innerHTML) :

            // Generate a reusable function that will serve as a template
            // generator (and which will be cached).
            new Function("obj",
                "var p=[],print=function(){p.push.apply(p,arguments);};" +
                // Introduce the data as local variables using with(){}
                "with(obj){p.push('" +
                // Convert the template into pure JavaScript
                //fixed single quotes issue - http://weblog.west-wind.com/posts/2008/Oct/13/Client-Templating-with-jQuery
                str.replace(/[\r\t\n]/g, " ")
                    .replace(/'(?=[^%]*%>)/g, "\t")
                    .split("'").join("\\'")
                    .split("\t").join("'")
                    .replace(/<%=(.+?)%>/g, "',$1,'")
                    .split("<%").join("');")
                    .split("%>").join("p.push('") +
                "');}return p.join('');");

        // Provide some basic currying to the user
        return data ? fn(data) : fn;
    };

    return {
        /**
         * 지정한 아이디에 해당되는 템플릿을 가져와 데이터를 입힌 마크업을 반환한다.
         *
         * @method reaction.templates#process
         * @param {String} templateId 템플릿 아이디
         * @param {Object} data 템플릿에 사용될 데이터 셋
         * @return {String} HTML 문자열
         */
        process: function (templateId, data) {
            return tmpl(templates[templateId], data);
        }
    };
};

/* jshint ignore:end */

reaction.Captcha = function (configures, message) {
    this._resources = {
        image: "/v1/captcha/{serviceId}/image",
        compare: "/v1/captcha/{serviceId}/compare"
    };
    this._conf = configures;
    this._apiDomain = this._conf._routeDomain || this._conf.domain;
    this._messages = message;
    this._templates = reaction.templates(this._messages.templates);
    this._key = "";
    this._$elBody = jQuery("body");
    this._isUseApigw = this._conf.isUseApigw;
};

reaction.Captcha.prototype = {
    constructor: reaction.Captcha,

    load: function (captchaInfos) {
        var requestParams = {
            abuseTypeCode: captchaInfos.abuseTypeCode
        };

        jQuery.ajax({
            url: (this._isUseApigw ? this._conf.apigwInfo.domain : this._apiDomain) + this._resources.image.replace("{serviceId}", captchaInfos.serviceId),
            dataType: "jsonp",
            scriptCharset: "utf-8",
            timeout: 3000,
            context: this,
            data: requestParams,
            success: function (res) {
                this._createLayer(captchaInfos, res);
                this._key = res.captchaKey;
                this._drawImage();
            },
            error: function () {
                alert(this._messages.templates.captcha.err_captcha);
            }
        });
    },
    _createLayer: function (captchaInfos, result) {
        this._$elBody.append(this._templates.process("captchaLayer", result));
        this._attachEvent(captchaInfos);
    },
    _deleteLayer: function () {
        jQuery(".u_likeit_captcha").remove();
    },
    _drawImage: function (imgSrc) {
        var $imgEl = jQuery(".u_likeit_captcha_img");

        if (!!imgSrc) {
            $imgEl.children("img").attr("src", imgSrc);
        }

        if (this._conf.isMobile) {
            $imgEl.children("img").attr("width", "244").attr("height", "90");

        } else {
            $imgEl.children("img").attr("width", "300").attr("height", "99");
        }
    },
    _refresh: function (captchaInfos) {
        var requestParams = {
            abuseTypeCode: captchaInfos.abuseTypeCode
        };

        jQuery.ajax({
            url: (this._isUseApigw ? this._conf.apigwInfo.domain : this._apiDomain) + this._resources.image.replace("{serviceId}", captchaInfos.serviceId),
            dataType: "jsonp",
            scriptCharset: "utf-8",
            timeout: 3000,
            context: this,
            data: requestParams,
            success: function (res) {
                this._drawImage(res.captchaImageUrl);
                this._key = res.captchaKey;
            },
            error: function () {
                alert(this._messages.templates.captcha.err_image);
            }
        });
    },
    _submit: function (captchaInfos) {
        var _$defense = jQuery("#likeit_captcha_defense");

        if (!!!_$defense.val()) {
            alert(this._messages.templates.captcha.err_empty);
            return;
        }

        var requestParams = {
            captchaKey: this._key,
            value: _$defense.val(),
            abuseTypeCode: captchaInfos.abuseTypeCode
        };

        jQuery.ajax({
            url: (this._isUseApigw ? this._conf.apigwInfo.domain : this._apiDomain) + this._resources.compare.replace("{serviceId}", captchaInfos.serviceId),
            dataType: "jsonp",
            scriptCharset: "utf-8",
            timeout: 3000,
            context: this,
            data: requestParams,
            success: function (res) {
                if (res.result === "OK") {
                    this._requestPreviousReaction();
                    this._close();
                } else {
                    alert(this._messages.templates.captcha.err_wrong);
                    this._drawImage(res.captchaImageUrl);
                    this._clearTextbox();
                    this._key = res.captchaKey;
                }
            },
            error: function () {
                alert(this._messages.templates.captcha.err_server);
                this._close();
            }
        });

    },
    _clearTextbox: function () {
        var _$inputArea = jQuery(".u_likeit_captcha_input_area");
        var _$defense = jQuery("#likeit_captcha_defense");

        _$defense.val("");
        _$inputArea.removeClass("u_likeit_captcha_focus");
    },
    _close: function () {
        this._deleteLayer();
        this._detachEvent();
        this._clearPreviousReaction();
    },
    _rotateHandler: function () {
        var $layerEl = jQuery(".u_likeit_captcha_wrap");
        $layerEl.hide();
        $layerEl.show();
    },
    _requestPreviousReaction: function () {
        jQuery(this).trigger("requestPreviousReaction");
    },
    _clearPreviousReaction: function () {
        jQuery(this).trigger("clearPreviousReaction");
    },
    _attachEvent: function (captchaInfos) {
        var $captcha_input = jQuery(".u_likeit_captcha_input_area");
        this._$elBody.on("click", ".u_likeit_captcha_close", jQuery.proxy(this._close, this))
            .on("click", ".u_likeit_captcha_refresh", jQuery.proxy(function () {
                this._refresh(captchaInfos);
            }, this))
            .on("click", ".u_likeit_captcha_submit", jQuery.proxy(function () {
                this._submit(captchaInfos);
            }, this))
            .on("focus", ".u_likeit_captcha_input", function () {
                $captcha_input.addClass("u_likeit_captcha_focus");
            })
            .on("blur", ".u_likeit_captcha_input", function () {
                if (jQuery(this).val() === "") {
                    $captcha_input.removeClass("u_likeit_captcha_focus");
                }
            });

        if ("onorientationchange" in window) {
            window.addEventListener("orientationchange", this._rotateHandler);
        }
    },
    _detachEvent: function () {
        this._$elBody.off("click", ".u_likeit_captcha_close")
            .off("click", ".u_likeit_captcha_refresh")
            .off("click", ".u_likeit_captcha_submit")
            .off("focus", ".u_likeit_captcha_input")
            .off("blur", ".u_likeit_captcha_input");

        if ("onorientationchange" in window) {
            window.removeEventListener("orientationchange", this._rotateHandler);
        }
    }
};

/**
 * @fileOverview [PC/M] 공감하기 > 버튼 모듈 파일
 * @author moonseok.kim@navercorp.com(Naver)
 * @since 2016.01.12
 */

/**
 * 공감하기 버튼 모듈
 *
 * @class reaction.Buttons
 * @constructor
 * @requires reaction.messages
 * @param {Object} configures 설정값 모음
 */
reaction.Buttons = function (configures, message) {
    this._resources = {
        content: "/v1/search/contents?suppress_response_codes=true",
        contentAdd: "/v1/services/{serviceId}/contents/{contentsId}?suppress_response_codes=true&_method=POST",
        contentCancel: "/v1/services/{serviceId}/contents/{contentsId}?suppress_response_codes=true&_method=DELETE",
        contentAddPeriod: "/v1/period/services/{serviceId}/contents/{contentsId}?suppress_response_codes=true&_method=POST",
        contentCancelPeriod: "/v1/period/services/{serviceId}/contents/{contentsId}?suppress_response_codes=true&_method=DELETE",
        contentAddNolimit: "/v1/nolimit/services/{serviceId}/contents/{contentsId}?suppress_response_codes=true&_method=POST",
        css: {
            common_basic: "/css/reaction/mobile/likeit.css",
            common_multi: "/css/reaction/mobile/likeit_multi.css",
            service: "/css/reaction/mobile/likeit_{cssId}.css",
            cssStaticUrl: {
                dev: "https://dev-static-feedback.naver.net/css/like/{cssId}/{assignId}/{staticId}/{file}.css",
                real: "https://static-feedback.pstatic.net/css/like/{cssId}/{assignId}/{staticId}/{file}.css"
            }
        },
        realNameCheck: {
            mobile: "https://nid.naver.com/mobile/user/help/realNameCheck?type=2&rurl=",
            pc: "https://nid.naver.com/user2/help/realNameCheck?type=2&rurl="
        }
    };
    this._conf = configures;
    this._displayId = this._conf.displayId;
    this._apiDomain = this._conf._routeDomain || this._conf.domain;
    this._routePool = this._conf._routePool;
    this._messages = message;
    this._isNeoid = (this._conf.authType === "neoid");
    this._isUseApigw = this._conf.isUseApigw;
    this._isUseApigw && this._setApigwResource();
    this._isNeoid && this._setNeoidResources();
    this._$body = jQuery(document);

    // Long/Short press 동작 제어 변수
    this._longPressThreshold = this._conf.longPressThreshold || 500; // ms
    this._pressTimer = null;
    this._leaveTimer = null;
    this._pressTarget = null;
    this._isMouseOverFace = false;
    this._isMouseOverLayer = false;
    this._isLongPressed = false;
    this._isPressing = false;

    this._onButtonHandler = jQuery.proxy(this._onButtonHandler, this);
    this._onNolimitButtonHandler = jQuery.proxy(this._onNolimitButtonHandler, this);
    this._onHideHandler = jQuery.proxy(this._onHideHandler, this);
    this._onFaceButtonHandler = jQuery.proxy(this._onFaceButtonHandler, this);
    this._onFaceButtonTextHandler = jQuery.proxy(this._onFaceButtonTextHandler, this);
    this._onCertificationHandler = jQuery.proxy(this._onCertificationHandler, this);
    this._removeLayer = jQuery.proxy(this._removeLayer, this);

    // Press 구분 관련 추가 핸들러 바인딩
    this._onPressStart = jQuery.proxy(this._onPressStart, this);
    this._onPressEndHandler = jQuery.proxy(this._onPressEndHandler, this);
    this._onPressEnd = jQuery.proxy(this._onPressEnd, this);
    this._onMouseLeave = jQuery.proxy(this._onMouseLeave, this);
    this._onMouseOverFace = jQuery.proxy(this._onMouseOverFace, this);
    this._onMouseOverLayer = jQuery.proxy(this._onMouseOverLayer, this);
    this._preventDefaultHandler = jQuery.proxy(this._preventDefaultHandler, this);

    this._attachEvent();
    this._maxLimitCount = 10;
    this._nolimitHistory = [];
    this._pollingNolimit();
    this._previousReaction = null;
    this._retryCount = 0;
    this._cssLaodRetryCount = 0;
    this._isRetryFinish = false;
    this._isLoadRetryFinish = false;
    this._contentsListRetryTimer = null;
    this._loadRetryTimer = null;
    this._$targetContentsList = null;
    this._isReactionRequestRetry = true;
    this._requestReactionTimeout = 10000;
    this._serviceOptionType = null;
    this._reactionTextMap = null;
};

/** @lends reaction.Buttons.prototype */
reaction.Buttons.prototype = {
    constructor: reaction.Buttons,

    _setNeoidResources: function () {
        jQuery.extend(this._resources, {
            content: this._conf.authInfo.domain + "/v1/search/contents?suppress_response_codes=true&token=" + this._conf.authInfo.token +
                "&consumerKey=" + this._conf.authInfo.consumerKey +
                "&snsCode=" + this._conf.authInfo.snsCode +
                "&pool=" + this._conf.authInfo.pool,
            contentAdd: this._conf.authInfo.domain + "/v1/services/{serviceId}/contents/{contentsId}?suppress_response_codes=true&_method=POST&token=" + this._conf.authInfo.token +
                "&consumerKey=" + this._conf.authInfo.consumerKey +
                "&snsCode=" + this._conf.authInfo.snsCode +
                "&pool=" + this._conf.authInfo.pool,
            contentCancel: this._conf.authInfo.domain + "/v1/services/{serviceId}/contents/{contentsId}?suppress_response_codes=true&_method=DELETE&token=" + this._conf.authInfo.token +
                "&consumerKey=" + this._conf.authInfo.consumerKey +
                "&snsCode=" + this._conf.authInfo.snsCode +
                "&pool=" + this._conf.authInfo.pool
        });
    },

    _setApigwResource: function () {
        jQuery.extend(this._resources, {
            content: this._conf.apigwInfo.domain + "/v1/search/contents?suppress_response_codes=true&pool=" + this._conf.apigwInfo.pool,
            contentAdd: this._conf.apigwInfo.domain + "/v1/services/{serviceId}/contents/{contentsId}?suppress_response_codes=true&_method=POST&pool=" + this._conf.apigwInfo.pool,
            contentCancel: this._conf.apigwInfo.domain + "/v1/services/{serviceId}/contents/{contentsId}?suppress_response_codes=true&_method=DELETE&&pool=" + this._conf.apigwInfo.pool,
            contentAddPeriod: this._conf.apigwInfo.domain + "/v1/period/services/{serviceId}/contents/{contentsId}?suppress_response_codes=true&_method=POST&pool=" + this._conf.apigwInfo.pool,
            contentCancelPeriod: this._conf.apigwInfo.domain + "/v1/period/services/{serviceId}/contents/{contentsId}?suppress_response_codes=true&_method=DELETE&pool=" + this._conf.apigwInfo.pool,
            contentAddNolimit: this._conf.apigwInfo.domain + "/v1/nolimit/services/{serviceId}/contents/{contentsId}?suppress_response_codes=true&_method=POST&pool=" + this._conf.apigwInfo.pool
        });
    },

    _attachEvent: function () {
        this._$body.on("click", this._onHideHandler)
            .on("click", "." + this._conf.moduleClassname + " a._nolimitButton", this._onNolimitButtonHandler)
            .on("click", "." + this._conf.moduleClassname + " a._button", this._onButtonHandler)
            .on("click", "." + this._conf.popupClassname + " a._button", this._onCertificationHandler)
            .on("click", "." + this._conf.popupClassname + " button", this._removeLayer);

        if (this._conf.isAllowLongPress) {
            var mouseDown = this._conf.isMobile ? "touchstart" : "mousedown";
            var mouseUp = this._conf.isMobile ? "touchend" : "mouseup";

            // 롱프레스 -> 드래그 -> 마우스 업 시 레이어 사라지지 않는 이슈를 해결하기 위해 MouseUp 이벤트를 바디에 추가
            this._$body.on(mouseUp, this._onPressEnd);

            this._$body
                .on(mouseDown, "." + this._conf.moduleClassname + " a._face:has(._longpress)", this._onPressStart)
                .on(mouseUp, "." + this._conf.moduleClassname + " a._face:has(._longpress)", this._onPressEndHandler)
                .on("contextmenu selectstart", "." + this._conf.moduleClassname + " a._face:has(._longpress)", this._preventDefaultHandler);

            if (!this._conf.isMobile) {
                this._$body
                    .on("mouseover", "." + this._conf.moduleClassname + " ._faceLayer", this._onMouseOverLayer)
                    .on("mouseleave", "." + this._conf.moduleClassname + " ._faceLayer", this._onMouseLeave);

                this._$body
                    .on("mouseover", "." + this._conf.moduleClassname + " a._face:has(._longpress)", this._onMouseOverFace)
                    .on("mouseleave", "." + this._conf.moduleClassname + " a._face:has(._longpress)", this._onMouseLeave);
            }

            // 안드로이드 네앱에서 길게 누르기시 ContextMenu 가 나오는 문제가 있어 추가.
            window.naverappapi && window.naverappapi.disableContextMenu && window.naverappapi.disableContextMenu();

            if (this._conf.callback.clickFaceButtonText) {
                this._$body
                    .on("click", "." + this._conf.moduleClassname + " a._face ._count", this._onFaceButtonTextHandler);
            }

        } else {
            if (this._conf.callback.clickFaceButtonText) {
                this._$body
                    .on("click", "." + this._conf.moduleClassname + " a._face ._count", this._onFaceButtonTextHandler)
                    .on("click", "." + this._conf.moduleClassname + " a._face ._icons", this._onFaceButtonHandler);
            } else {
                this._$body
                    .on("click", "." + this._conf.moduleClassname + " a._face", this._onFaceButtonHandler);
            }
        }
    },

    _onHideHandler: function (evt) {
        var $el = jQuery(evt.target);

        if (this._isLongPressed) {
            this._isLongPressed = false;
            return;
        }

        if (this._conf.isHiddenLayerAfterSelection || (!$el.hasClass("_button") && !$el.hasClass("_face"))) {
            this._hideLayers();
        }
    },

    _onFaceButtonHandler: function (evt) {
        var $button = jQuery(evt.currentTarget);

        if ($button) {
            var $layer = $button.closest("." + this._conf.moduleClassname).find("._faceLayer").first();

            var serviceId = $button.closest("[data-sid]").attr("data-sid");

            var isOpen = $layer.is(":visible");
            if (isOpen) {
                $layer.hide();
                if (this._isSendNlog(serviceId)) {
                    $button.attr("data-like-click-area", "face.release");
                }

            } else {
                this._hideLayers();
                $layer.show();
                if (this._isSendNlog(serviceId)) {
                    $button.attr("data-like-click-area", "face.close");
                }
            }

            var faceLayerToggle = this._conf.callback && this._conf.callback.faceLayerToggle;
            if (typeof faceLayerToggle === "function") {
                faceLayerToggle({open: !isOpen, target: $layer[0]});
            }
        }
        evt.stopPropagation();
    },

    _onFaceButtonTextHandler: function (evt) {
        var $base = jQuery(evt.currentTarget).closest("." + this._conf.moduleClassname).first();
        this._conf.callback.clickFaceButtonText($base.attr("data-cid"));
    },

    _onMouseOverLayer: function () {
        this._isMouseOverLayer = true;
        this._resetTimers();
    },

    _onMouseOverFace: function (evt) {
        this._isMouseOverFace = true;
        this._resetLeaveTimer();

        var $button = jQuery(evt.currentTarget);
        var $layer = $button.closest("." + this._conf.moduleClassname).find("._faceLayer").first();
        if (this._isPressing || $layer.is(":visible")) {
            return;
        }

        var self = this;
        this._leaveTimer = setTimeout(function () {
            if (self._isMouseOverFace) {
                self._onFaceButtonHandler(evt);
            }
        }, this._longPressThreshold);
    },

    _onPressStart: function (evt) {
        if (this._isPressing) {
            // 누르는 중이면 이벤트를 발생하지 않는다.
            return;
        }

        var $button = jQuery(evt.currentTarget);

        // 멀티 터치
        if (evt.type === "touchstart" && evt.originalEvent && evt.originalEvent.touches && evt.originalEvent.touches.length > 1) {
            return;
        }

        this._pressTarget = $button[0];
        $button.data("pressCancelled", false);
        this._isLongPressed = false;
        this._isPressing = true;
        this._resetTimers();

        var self = this;
        this._pressTimer = setTimeout(function () {
            if ($button.data("pressCancelled")) {
                return;
            }
            self._isLongPressed = true;
            self._onFaceButtonHandler(evt);
        }, this._longPressThreshold);
    },

    _onPressEndHandler: function (evt) {
        this._onPressEnd(evt);
        evt.preventDefault();
        evt.stopPropagation();
    },

    _onPressEnd: function (evt) {
        if (!this._isPressing) {
            return;
        }

        var $button = jQuery(evt.currentTarget);
        this._resetPressTimer();
        this._isPressing = false;

        // long press가 된 경우, click 동작을 억제한다.
        if (this._isLongPressed) {
            // 상태 초기화
            $button.data("pressCancelled", false);

            // 모바일에서 touchstart - touchend 시 click 이벤트가 발생되지 않아 _isLongPressd 가 초기화 되지 않는 문제가 있어
            // touchend 에서만 직접 초기화 처리
            if (evt.type === "touchend") {
                evt.preventDefault();

                // ipad 에서는 모바일과 다르게 click 이벤트가 발행되는 문제가 있어 비동기로 처리하도록 추가
                var self = this;
                setTimeout(function () {
                    self._isLongPressed = false;
                }, 100);
            }
        } else {
            var $faceLayer = $button.siblings("._faceLayer");
            var $targetReaction;

            // 공감이 된 값이 있다면 해당 공감타입 사용 아니라면 초기화시 지정된 값 사용
            if ($faceLayer.find("a._button.on").length > 0) {
                $targetReaction = $faceLayer.find("a._button.on").parent();
            } else {
                $targetReaction = $faceLayer.children("." + this._conf.defaultReactionType);
            }

            // 만약 초기화시 값이 지정되어 있지 않다면 리스트 가장 첫번째 값 사용
            if ($targetReaction.length === 0) {
                $targetReaction = $faceLayer.children().first();
            }
            this._onButtonHandler({currentTarget: null}, $targetReaction.children().first()[0]);
        }
    },

    _onMouseLeave: function () {
        var $button = this._pressTarget ? jQuery(this._pressTarget) : null;
        this._resetTimers();
        if ($button) {
            $button.data("pressCancelled", true);
        }
        this._pressTarget = null;
        var self = this;
        this._leaveTimer = setTimeout(function () {
            if (self._isMouseOverFace || self._isMouseOverLayer) {
                self._isMouseOverFace = false;
                self._isMouseOverLayer = false;
                self._hideLayers();
            }
        }, this._longPressThreshold);
    },

    _preventDefaultHandler: function (evt) {
        evt.preventDefault();
    },

    _getCountButton: function ($button) {
        return $button.find("._count").first();
    },

    /**
     * @param customEventParams
     * @returns {boolean|*} callback.click 결과가 undefined 또는 true 이면 true, 아니면 false
     *                        명시적으로 `return false;` 로 callback.click 을 정의했을 때만 false 이다.
     * @private
     */
    _callClickCallback: function (customEventParams) {
        var callbackResult = this._conf.callback &&
            this._conf.callback.click &&
            this._conf.callback.click(customEventParams);
        return callbackResult === undefined || callbackResult;
    },

    _checkGuestReactionApproved: function (buttonElement) { //비회원 공감 허용 여부 확인
        var guestCode = "006";
        var $target = jQuery(buttonElement);
        var serviceId = $target.closest("." + this._conf.moduleClassname).attr("data-sid");

        var option = this._serviceOptionType[serviceId];
        if (option !== undefined) {
            if (option[guestCode] !== undefined) {
                return option[guestCode];
            }
        }
        return false;
    },

    _resetTimers: function () {
        this._resetPressTimer();
        this._resetLeaveTimer();
    },

    _resetPressTimer: function () {
        if (this._pressTimer) {
            clearTimeout(this._pressTimer);
            this._pressTimer = null;
        }
    },

    _resetLeaveTimer: function () {
        if (this._leaveTimer) {
            clearTimeout(this._leaveTimer);
            this._leaveTimer = null;
        }
    },

    _onButtonHandler: function (evt, button) {
        var buttonElement = evt.currentTarget || button,
            isAdding = !jQuery(buttonElement).hasClass(this._conf.iconToggleClassname[0]),
            customEventParams = {
                event: evt.originalEvent,
                target: buttonElement,
                isAdding: isAdding
            };
        jQuery(buttonElement).closest("._face + ._faceLayer").length && this._hideLayers();
        evt.preventDefault && evt.preventDefault();

        this._isMouseOverFace = false;
        this._isMouseOverLayer = false;
        this._isLongPressed = false;
        this._isPressing = false;

        if (!this._callClickCallback(customEventParams)) {
            return;
        }

        if (this._isLogin || this._checkGuestReactionApproved(buttonElement)) {
            if (isAdding) {
                this.increase(buttonElement);
            } else {
                this.decrease(buttonElement);
            }
        } else {
            this._redirectLogin();
        }

        /**
         * 공감하기 버튼 클릭시 발생
         *
         * @name reaction.Buttons#clickReaction
         * @event
         * @param {Object} customEventParams
         *   @param {Event} customEventParams.event 이벤트 객체
         *   @param {Boolean} customEventParams.isAdding 공감/취소 여부(true: 공감, false; 취소)
         */
        jQuery(this).trigger("clickReaction", customEventParams);
    },
    _onNolimitButtonHandler: function (evt) {
        var buttonElement = evt.currentTarget,
            customEventParams = {
                event: evt.originalEvent,
                target: buttonElement,
                isAdding: true
            };
        jQuery(buttonElement).closest("._face + ._faceLayer").length && this._hideLayers();
        evt.preventDefault();

        if (!this._callClickCallback(customEventParams)) {
            return;
        }
        if (this._isLogin || this._checkGuestReactionApproved(buttonElement)) {
            this.increaseNolimit(buttonElement);
        } else {
            this._redirectLogin();
        }

        /**
         * 공감하기 버튼 클릭시 발생
         *
         * @name reaction.Buttons#clickReaction
         * @event
         * @param {Object} customEventParams
         *   @param {Event} customEventParams.event 이벤트 객체
         *   @param {Boolean} customEventParams.isAdding 공감/취소 여부(true: 공감, false; 취소)
         */
        jQuery(this).trigger("clickReaction", customEventParams);
    },

    _onCertificationHandler: function () {
        var returnURL = location.href;
        top.location.href = (this._conf.isMobile ? this._resources.realNameCheck.mobile : this._resources.realNameCheck.pc) + encodeURIComponent(returnURL) + "&surl=" + encodeURIComponent(returnURL);
    },

    _removeLayer: function () {
        jQuery("." + this._conf.popupClassname).remove();
    },

    _hideLayers: function () {
        var $el;
        var self = this;
        jQuery(jQuery.grep(jQuery("." + this._conf.moduleClassname).find("._faceLayer:visible"), function (v) {
            $el = jQuery(v);
            return $el.is(":visible") && !!$el.parent().find("._face").length;
        })).each(function () {
            $el = jQuery(this);
            $el.hide();
            if (self._conf.callback && typeof self._conf.callback.faceLayerToggle === "function") {
                self._conf.callback.faceLayerToggle({
                    open: false,
                    target: $el[0]
                });
            }

            var serviceId = $el.closest("[data-sid]").attr("data-sid");
            if (self._isSendNlog(serviceId)) {
                var $face = $el.siblings("._face");
                if (self._conf.callback.clickFaceButtonText) {
                    $face.find("._icons").attr("data-like-click-area", "face.release");
                } else {
                    $face.attr("data-like-click-area", "face.release");
                }
            }
        });
    },

    _detachEvent: function () {
        this._$body
            .off("click", this._onHideHandler)
            .off("click", "." + this._conf.moduleClassname + " a._button", this._onButtonHandler)
            .off("click", "." + this._conf.moduleClassname + " a._nolimitButton", this._onNolimitButtonHandler);

        if (this._conf.isAllowLongPress) {
            // 롱프레스 -> 드래그 -> 마우스 업 시 레이어 사라지지 않는 이슈를 해결하기 위해 MouseUp 이벤트를 바디에 추가
            this._$body
                .off("touchend mouseup", this._onPressEnd);

            this._$body
                .off("mouseover", "." + this._conf.moduleClassname + " ._faceLayer", this._onMouseOverLayer)
                .off("mouseleave", "." + this._conf.moduleClassname + " ._faceLayer", this._onMouseLeave);

            this._$body
                .off("mouseover", "." + this._conf.moduleClassname + " a._face:has(._longpress)", this._onMouseOverFace)
                .off("mouseleave", "." + this._conf.moduleClassname + " a._face:has(._longpress)", this._onMouseLeave)
                .off("touchstart mousedown", "." + this._conf.moduleClassname + " a._face:has(._longpress)", this._onPressStart)
                .off("mouseup touchend", "." + this._conf.moduleClassname + " a._face:has(._longpress)", this._onPressEndHandler)
                .off("contextmenu selectstart", "." + this._conf.moduleClassname + " a._face:has(._longpress)", this._preventDefaultHandler);

            if (this._conf.callback.clickFaceButtonText) {
                this._$body
                    .off("click", "." + this._conf.moduleClassname + " a._face ._count", this._onFaceButtonTextHandler);
            }
        } else {
            if (this._conf.callback.clickFaceButtonText) {
                this._$body
                    .off("click", "." + this._conf.moduleClassname + " a._face ._count", this._onFaceButtonTextHandler)
                    .off("click", "." + this._conf.moduleClassname + " a._face ._icons", this._onFaceButtonHandler);
            } else {
                this._$body
                    .off("click", "." + this._conf.moduleClassname + " a._face", this._onFaceButtonHandler);
            }
        }
    },

    //Android inApp에서 confirm 창이 뜨지 않는 이슈로 agent 체크
    _isAndroidConfirmBugInApp: function () {
        return /Android 5.+Chrome\/40.+NAVER.+inapp/.test(navigator.userAgent);
    },

    /**
     * 로그인 페이지로 이동(NEOID인 경우 loginHandler callback 실행)
     *
     * @private
     * @param {String} message 로그인 안내 문구
     */
    _redirectLogin: function () {
        if (this._isNeoid) {
            if (this._isAndroidConfirmBugInApp() || confirm(this._messages.login.neoid)) {
                this._conf.authInfo.loginHandler();
            }
        } else {
            if (this._isAndroidConfirmBugInApp() || confirm(this._messages.login.nid)) {
                top.location.href = "https://nid.naver.com/nidlogin.login?" +
                    (this._conf.isMobile ? "svctype=262144&" : "") +
                    "url=" + encodeURIComponent(location.href) +
                    "&locale=" + (this._conf.language === "ko" ? "ko_KR" : "en_US");
            }
        }
    },

    // 공감, 취소는 클라이언트에서 맞춘다.
    // 이전에 선택된 버튼이 있다면 반환한다.
    _updateReactionFromClient: function ($buttons, isAdding, $restoreButtons, count, isUpdateServerCount) {
        var prevButtons = [];
        var $prevBtn = null;
        var moduleClass = "." + this._conf.moduleClassname;
        $buttons.each(jQuery.proxy(function (i, el) {
            var $button = jQuery(el),
                $base = $button.closest(moduleClass).first(),
                isFaceType = this._isFace($base),
                duplication = $base.attr("data-duplication") || !!this._conf.isDuplication;
            duplication = typeof duplication === "boolean" ? duplication : (duplication + "").toLowerCase() === "true";
            if (!duplication) {
                if ($restoreButtons) {
                    this._cleanReaction($restoreButtons.get(i), isAdding === false ? false : undefined, count);
                } else {
                    // 주변 count -1, 클래스 제거. 삭제시, 자신의 엘리먼트는 제외하고 처리
                    $prevBtn = $base.find((isFaceType ? "._faceLayer " : "") + "." + this._conf.iconToggleClassname[0]);
                    $prevBtn = $prevBtn.is($button) ? $prevBtn.not($button) : $prevBtn;
                    if (!isFaceType) {
                        // 중복 처리
                        var $parent = $button.parent();
                        $prevBtn = $prevBtn.filter(function (k, v) {
                            var $prev = jQuery(v);
                            var $prevParent = $prev.parent();
                            return (($prevParent.attr("data-sid") !== $parent.attr("data-sid")) ||
                                ($prevParent.attr("data-cid") !== $parent.attr("data-cid")) ||
                                ($prev.attr("data-type") !== $button.attr("data-type")));
                        });
                    }
                    this._cleanReaction($prevBtn, true, count);
                }
            }
            prevButtons.push($prevBtn);

            var currentCount = this._toNum(this._getCountButton($button).text());
            var isDisplayMax = currentCount >= this._conf.maxCount;
            var clientCnt = isDisplayMax ? currentCount : currentCount + (isAdding ? count : -count);
            var displayCount = isUpdateServerCount ? count : clientCnt;

            this._updateButton($base, $button, isAdding, displayCount);

            // 클라이언트에서 숫자를 맞춘다.
            isFaceType && this._updateFaceButton($base.find("._face").first(), undefined, undefined, undefined, $base.attr("data-markUserReaction"));
        }, this));

        return jQuery(prevButtons);
    },

    _cleanReaction: function ($buttons, isAdding, count) {
        var self = this,
            $el, $count;
        $buttons.length && $buttons
            .each(function (k, e) {
                $el = jQuery(e).toggleClass(self._conf.iconToggleClassname.join(" "));
                $count = self._getCountButton($el);
                $count.text(self._formattedCount(self._toNum($count.text()) + (typeof isAdding === "undefined" ? 0 : (isAdding ? -count : count))));
            });
    },

    /**
     * 공감 또는 취소를 요청할 API KEY를 선택한다.
     * @param isAdding 공감하기이면 true
     * @param countType
     * @private
     */
    _selectApiKey: function (isAdding, countType) {
        var postfix = !!countType ? countType.charAt(0).toUpperCase() + countType.substring(1, countType.length) : "";

        if (isAdding) {
            return "contentAdd" + postfix;
        } else {
            return "contentCancel" + postfix;
        }
    },

    /**
     * 무한공감 카운트, 히스토리, wait, 무한공감 자동갱신(공감 클릭시 클릭 시점부터 재시작) 초기화
     * @private
     * @param count
     * @param history
     */
    _afterNolimitReqeust: function () {
        clearTimeout(this._nolimitTimer);
        this._nolimitHistory = [];
        this._wait = false;
        this._pollingNolimit();
    },

    /**
     * Captcha로 인해서 블로킹되었던 요청을 재전송한다.
     */
    requestPreviousReaction: function () {
        if (!this._previousReaction) {
            return;
        }
        this._requestReaction(this._previousReaction.buttonElement, this._previousReaction.isAdding);
    },

    /**
     * captcha 임시 데이터 삭제.
     */
    clearPreviousReaction: function () {
        this._previousReaction = null;
    },

    /**
     * captcha 통과시 재전송할 데이터 설정
     */
    _setPreviousReaction: function (buttonElement, isAdding) {
        this._previousReaction = {
            buttonElement: buttonElement,
            isAdding: isAdding
        };
    },

    /**
     * 공감/취소하기
     *
     * @private
     * @param {HTMLElement|jQuery} buttonElement 버튼 엘리먼트
     * @param {Boolean} isAdding 공감/취소 여부(true: 공감, false; 취소)
     */
    _requestReaction: function (buttonElement, isAdding) {
        var $target = jQuery(buttonElement),
            $base = $target.closest("." + this._conf.moduleClassname),
            $buttons = jQuery().add($target),
            serviceId = $base.attr("data-sid"),
            contentId = $base.attr("data-cid"),
            parentContentsId = $base.attr("data-pid"),
            categoryId = $base.attr("data-catgid") || "",
            displayId = $base.attr("data-did") || this._displayId || serviceId,
            friendsLayerId = $base.attr("data-friendslayer-id") || "",
            reactionType = $target.attr("data-type"),
            reactionViewType = $target.attr("data-viewtype") || "",
            duplication = $base.attr("data-duplication") || !!this._conf.isDuplication,
            contentCountType = $base.attr("data-ccounttype"),
            count = 1,
            history = [],
            isNolimitType = contentCountType === "nolimit",
            btnClassName = isNolimitType ? "._nolimitButton" : "._button",
            runtimeStatus = "";//before,live,after

        if (isNolimitType) {
            count = this._nolimitHistory.length,
                history = this._nolimitHistory,
                runtimeStatus = this._conf.runtimeStatus();
        }

        var requestParams = {
                displayId: displayId,
                reactionType: reactionType,
                categoryId: categoryId,
                guestToken: reaction._guestToken,
                timestamp: reaction._timestamp,
                _ch: this._conf.isMobile ? "mbw" : "pcw",
                isDuplication: typeof duplication === "boolean" ? duplication : (duplication + "").toLowerCase() === "true",
                lang: this._conf.language,
                countType: contentCountType || "default",
                count: count,
                history: isNolimitType ? history.join("|") : "",
                runtimeStatus: runtimeStatus
            },
            customEventParams = {
                $base: $base,
                $target: $target,
                serviceId: serviceId,
                contentId: contentId,
                displayId: displayId,
                friendsLayerId: friendsLayerId,
                reactionType: reactionType,
                reactionViewType: reactionViewType,
                isAdding: isAdding,
                isNeoid: this._isNeoid
            },
            apiKey = this._selectApiKey(isAdding, contentCountType);

        if (isAdding) {
            requestParams.isPostTimeline = !!(friendsLayerId);
        }

        if (!!reactionViewType) {
            requestParams.viewType = reactionViewType;
        }

        if (!!parentContentsId) {
            requestParams.parentContentsId = parentContentsId;
        }

        //동일한 버튼이 있으면 클릭한 버튼 다음으로 추가
        var $sameButton = jQuery("." + this._conf.moduleClassname).not($base).filter(function () {
            var $others = jQuery(this);
            return $others.attr("data-sid") === serviceId && $others.attr("data-cid") === contentId;
        }).find(btnClassName + "[data-type=" + reactionType + "]");
        if ($sameButton.length) {
            $buttons = $buttons.add($sameButton);
        }

        // 클라이언트에서 버튼 update
        var $prevButtons;
        if (!isNolimitType) {
            $prevButtons = this._updateReactionFromClient($buttons, isAdding, undefined, count, false);
        }

        //무한공감 히스토리, wait, timer 초기화
        isNolimitType && this._afterNolimitReqeust();

        //공감 or 취소하기 요청
        jQuery.ajax({
            url: (this._isNeoid || this._isUseApigw ? "" : this._apiDomain) + this._resources[apiKey].replace("{serviceId}", serviceId).replace("{contentsId}", contentId),
            dataType: "jsonp",
            scriptCharset: "utf-8",
            timeout: 3000,
            data: requestParams,
            context: this,
            success: function (res) {
                if (!res.errorCode || res.errorCode === 4042 || res.errorCode === 4004) {/* 정상인 것처럼 동작*/
                    /**
                     * 공감 or 취소하기 성공시 버튼 갱신 후 발생
                     *
                     * @name reaction.Buttons#successReaction
                     * @event
                     * @param {Object} customEventParams
                     *   @param {jQuery} customEventParams.$base 클릭한 버튼의 상위 기준 엘리먼트를 래핑한 jQuery 객체
                     *   @param {jQuery} customEventParams.$target 클릭한 버튼 엘리먼트를 래핑한 jQuery 객체
                     *   @param {String} customEventParams.serviceId 서비스 아이디
                     *   @param {String} customEventParams.contentId 컨텐츠 아이디
                     *   @param {String} customEventParams.categoryId 카테고리 아이디
                     *   @param {String} customEventParams.displayId 노출용 서비스 아이디
                     *   @param {String} customEventParams.friendsLayerId 친구목록레이어 아이디
                     *   @param {String} custo_pollingNolimitmEventParams.reactionType 공감하기 타입
                     *   @param {String} customEventParams.reactionViewType 공감하기 뷰타입
                     *   @param {Boolean} customEventParams.isAdding 공감 or 취소 여부(true: 공감, false: 취소)
                     *   @param {Boolean} customEventParams.isNeoid NeoID 인증 사용 여부(true: neoid, false: nid)
                     *   @param {Object} customEventParams.snsInfo SNS 연동 관련 정보
                     */
                    if (res.snsInfo) {
                        customEventParams.snsInfo = res.snsInfo;
                    }

                    //nolimitType이면 서버 카운트로 업데이트한다.
                    isNolimitType && this._updateReactionFromClient($buttons, isAdding, undefined, res.count, true);

                    jQuery(this).trigger("successReaction", customEventParams);

                    //공감하기 클릭시
                    this._conf.callback && this._conf.callback.clicked && this._conf.callback.clicked({
                        targets: $buttons.get(),
                        content: res
                    });
                    this._triggerParentCallback(res);
                } else if (res.errorCode === 4010) { // 로그인이 필요한 경우
                    // @실패시 처리.
                    !isNolimitType && this._updateReactionFromClient($buttons, !isAdding, $prevButtons, count, false);
                    this._redirectLogin();
                } else if (res.errorCode === 4016) { // 실명인증이 필요한 경우
                    // @실패시 처리.
                    !isNolimitType && this._updateReactionFromClient($buttons, !isAdding, $prevButtons, count, false);
                    jQuery("body").append(reaction.templates(this._messages.templates).process("certificationLayer", {}));
                } else if (res.errorCode === 4038) { // 캡챠 노출
                    // 마지막 요청된 reaction을 보존한다.
                    this._setPreviousReaction(buttonElement, isAdding);
                    res.moreInfos[0].serviceId = serviceId;
                    jQuery(this).trigger("captchaReaction", res.moreInfos[0]);
                    !isNolimitType && this._updateReactionFromClient($buttons, !isAdding, $prevButtons, count, false);
                } else if (res.errorCode === 4013 && this._isReactionRequestRetry) { //token값 오류, 1회만 수행.
                    this._isReactionRequestRetry = false;
                    this._finishContentsListRetry();
                    this._requestContentList(this._$targetContentsList);
                    this._clearTargetContentsList();

                    var intervalCount = 1;
                    var intervalTime = 500;
                    var maxIntervalCount = this._requestReactionTimeout / intervalTime + 2; //get요청 timeout이 10초로 되어있어 11초동안 요청함.
                    var self = this;
                    var $buttonEl = jQuery(buttonElement);

                    var intervalId = setInterval(function () {
                        self._requestReactionIntervalId = intervalId;
                        if (intervalCount > maxIntervalCount) { //최종 실패시
                            clearInterval(intervalId);
                            !isNolimitType && self._updateReactionFromClient($buttons, !isAdding, $prevButtons, count, false);
                            alert(res.message);
                            jQuery(self).trigger("errorReaction", customEventParams);
                            return;
                        }

                        if ($buttonEl.parents().attr("data-loaded") === "1") {
                            clearInterval(intervalId);
                            var _isAdding = true;
                            if (isNolimitType) {
                                _isAdding = $buttonEl.attr("aria-selected") === "true" ? false : true; //로딩 결과로 좋아요 한 여부를 결정한다.
                            } else {
                                _isAdding = $buttonEl.attr("aria-pressed") === "true" ? false : true; //로딩 결과로 좋아요 한 여부를 결정한다.
                            }
                            self._requestReaction(buttonElement, _isAdding);
                            return;
                        }
                        intervalCount++;
                    }, intervalTime);
                } else {
                    if (typeof this._requestReactionIntervalId !== "undefined") {
                        clearInterval(this._requestReactionIntervalId);
                    } else {
                        //+1된 상태에서 -1 정상상태로 돌아왔으나 아래 구분으로 인해 다시 +1 되는것 방지
                        !isNolimitType && this._updateReactionFromClient($buttons, !isAdding, $prevButtons, count, false);
                    }
                    alert(res.message);
                    /**
                     * 공감 or 취소하기 실패시 발생
                     *
                     * @name reaction.Buttons#errorReaction
                     * @event
                     * @param {Object} customEventParams
                     *   @param {jQuery} customEventParams.$base 클릭한 버튼의 상위 기준 엘리먼트를 래핑한 jQuery 객체
                     *   @param {jQuery} customEventParams.$target 클릭한 버튼 엘리먼트를 래핑한 jQuery 객체
                     *   @param {String} customEventParams.serviceId 서비스 아이디
                     *   @param {String} customEventParams.contentId 컨텐츠 아이디
                     *   @param {String} customEventParams.displayId 노출용 서비스 아이디
                     *   @param {String} customEventParams.friendsLayerId 친구목록레이어 아이디
                     *   @param {String} customEventParams.reactionType 공감하기 타입
                     *   @param {String} customEventParams.reactionViewType 공감하기 뷰타입
                     *   @param {Boolean} customEventParams.isAdding 공감 or 취소 여부(true: 공감, false: 취소)
                     *   @param {Boolean} customEventParams.isNeoid NeoID 인증 사용 여부(true: neoid, false: nid)
                     */
                    jQuery(this).trigger("errorReaction", customEventParams);
                }
            },
            error: function () {
                // @실패시 처리.
                !isNolimitType && this._updateReactionFromClient($buttons, !isAdding, $prevButtons, count, false);
                alert(this._messages.error);
                jQuery(this).trigger("errorReaction", customEventParams);
            }
        });
    },

    /**
     * APIDomain별로 Ajax 요청을 분리하기 위한 선작업으로,
     * 모든 공감하기 기준 엘리먼트에서 설정값(data-attribute)를 추출하여 JSON 포맷으로 구조화한다.
     *
     * @private
     * @param {jQuery} $target 공감하기 jQuery 객체
     * @return {Array} requestQueue 요청에 필요한 데이터
     *      컨텐츠마다 옵션을 지정할 때는 contentId 뒤에 옵션을 ()로 감싼다.
     *      사용 가능한 옵션 : ReactionCountType (DEFAULT, NOLIMIT, PERIOD)
     * @example
     *    requestQueue = [
     *        { //API 도메인 그룹
     *            "domain": "//search.like.naver.com",
     *            "services": [{ //서비스 그룹
     *                "serviceId": "MOVIE",
     *                "contentIds": [111,222,333]
     *                "parentIds": [1]
     *            },
     *            {
     *                "serviceId": "AUTO",
     *                "contentIds": [car_111,car_222],
     *                "parentIds": [2]
     *            },
     *            {
     *                "serviceId": "JOURNALIST",
     *                "contentIds": [111(period),222,333],
     *                "parentIds": []
     *            }],
     *            "duplication": true
     *        },
     *       {
     *            "domain": "//dev.m.like.naver.com",
     *            ...
     *            "duplication": false
     *        }
     *    ];
     */
    _getRequestQueue: function ($target) {
        if ($target == null) {
            return [];
        }

        var self = this,
            requestQueue = [],
            domainQueue = [],
            domainQueueIndex = -1,
            serviceIndex = -1;

        $target.each(function () {
            var $base = jQuery(this),
                domain = $base.attr("data-domain") || self._apiDomain,
                serviceId = $base.attr("data-sid"),
                contentId = $base.attr("data-cid"),
                parentId = $base.attr("data-pid"),
                duplication = $base.attr("data-duplication") || !!self._conf.isDuplication,
                contentCountType = $base.attr("data-ccounttype"),
                contentIds,
                parentIds;
            duplication = typeof duplication === "boolean" ? duplication : (duplication + "").toLowerCase() === "true";

            domainQueueIndex = jQuery.inArray(domain, domainQueue);
            if (domainQueueIndex < 0 || (requestQueue[domainQueueIndex].duplication !== duplication)) {	// domain이 없거나, domain이 있고, duplication이 다른 경우. 이때는 추가
                domainQueue.push(domain);
                domainQueueIndex = domainQueue.length - 1;
                requestQueue[domainQueueIndex] = {
                    "domain": domain,
                    "duplication": duplication,
                    "services": []
                };
            }

            serviceIndex = jQuery.map(requestQueue[domainQueueIndex].services, function (v) {
                return v.serviceId;
            }).indexOf(serviceId);

            if (serviceIndex < 0) {
                requestQueue[domainQueueIndex].services.push({
                    "serviceId": serviceId,
                    "contentIds": [],
                    "parentIds": []
                });
                serviceIndex = requestQueue[domainQueueIndex].services.length - 1;
            }

            //중복일 경우, 중복처리
            contentIds = requestQueue[domainQueueIndex].services[serviceIndex].contentIds;
            parentIds = requestQueue[domainQueueIndex].services[serviceIndex].parentIds;

            // 컨텐츠별로 지정한 옵션 추가
            contentId = !!contentCountType ? contentId + "(" + contentCountType + ")" : contentId;
            (!~jQuery.inArray(contentId, contentIds)) && contentIds.push(contentId);
            parentId && (!~jQuery.inArray(parentId, parentIds)) && parentIds.push(parentId);
        });
        return requestQueue;
    },

    /**
     * API 요청 파라미터(params)에 맞게 문자열로 변환한다.
     *
     * @private
     * @param {Array} services 서비스별 컨텐츠 아이디 목록
     * @param {String} idName 생성할 Id의 이름
     * @return {String} convertedParams 변환된 문자열
     * @example
     * convertedParams = "MOVIE[111,222,333]|AUTO[car_111,car_222]|BOOK[111,222,333]";
     */
    _convertToParamString: function (services, idName) {
        var params = [];
        for (var i = 0, nLen = services.length; i < nLen; i++) {
            services[i][idName].length && params.push(services[i].serviceId + "[" + services[i][idName].join(",") + "]");
        }
        return params.join("|");
    },

    /**
     * Array타입의 응답결과를 유니크한 키({serviceId}_{contentsId})를 가진 맵데이터 형태로 변환한다.
     *
     * @private
     * @param {Array} content 카운트 API의 응답결과(res.contents)
     * @return {Object} convertedData 변환된 데이터셋
     * @example
     * // 일반 컨텐츠 일 경우
     * convertedData = {
     *   //{serviceId}_{contentsId}
     *   "MOVIE_10000": {
     *       "like" ; { reactionType: "like", count: 9999, isReacted ; true },
     *       "want": { reactionType: "want", count: 9999, isReacted ; false },
     *       "haha": { reactionType: "haha", count: 9999, isReacted ; false },
     *       "warm": { reactionType: "warm", count: 9999, isReacted ; false },
     *       "wow": { reactionType: "wow", count: 9999, isReacted ; false },
     *       "sad": { reactionType: "sad", count: 9999, isReacted ; false },
     *       "angry": { reactionType: "angry", count: 9999, isReacted ; false }
     *   },
     *   "MOVIE_10001": { ... },
     *   ...
     * };
     * // 부모 컨텐츠 일 경우
     * convertedData = {
     *   //{serviceId}_{contentsId}
     *   "MOVIE": {
     *        "10000": {
     *          "like" ; { reactionType: "like", count: 9999, isReacted ; true },
     *          "want": { reactionType: "want", count: 9999, isReacted ; false },
     *          "haha": { reactionType: "haha", count: 9999, isReacted ; false },
     *          "warm": { reactionType: "warm", count: 9999, isReacted ; false },
     *        "wow": { reactionType: "wow", count: 9999, isReacted ; false },
     *          "sad": { reactionType: "sad", count: 9999, isReacted ; false },
     *        "angry": { reactionType: "angry", count: 9999, isReacted ; false }
     *      }
     *   },
     *   ...
     * };
     */
    _convertToMapData: function (contents) {
        var convertedData = {};

        jQuery.each(contents, function (i, content) {
            var reactionData = {};
            var isParent = !!("parentReactions" in content);

            jQuery.each(content[isParent ? "parentReactions" : "reactions"], function (j, data) {
                reactionData[data.reactionType] = data;
            });
            if (isParent) {
                convertedData[content.serviceId] = convertedData[content.serviceId] || {};
                convertedData[content.serviceId][content.parentContentsId] = reactionData;
            } else {
                convertedData[content.serviceId + "_" + content.contentsId] = reactionData;
            }
            convertedData[content.serviceId + "_reactionTextMap"] = content.reactionTextMap;
            convertedData[content.serviceId + "_customized"] = content.customized;
            convertedData[content.serviceId + "_differentPlatform"] = content.differentPlatform;
        });
        return convertedData;
    },

    _triggerParentCallback: function (res) {
        // parentContents 정보를 trigger
        this._conf.callback && res.parentContents && this._conf.callback.updateParent &&
        this._conf.callback.updateParent(this._convertToMapData(res.parentContents));
    },
    /**
     * 컨텐츠 retry 성공 및 실패시 처리 로직
     * @private
     */
    _finishContentsListRetry: function () {
        clearTimeout(this._contentsListRetryTimer);
        this._isRetryFinish = true;
    },
    /**
     * 컨텐츠 retry
     * @param $target
     * @param message
     * @private
     */
    _contentsListRetry: function ($target) {
        this._setTargetContentsList($target);

        try {
            var retryLimit = 3,
                retryInterval = 7000;

            if (this._isRetryFinish) {
                return;
            }
            if (this._retryCount >= retryLimit) {
                this._finishContentsListRetry();
                return;
            }

            this._retryCount = this._retryCount + 1;
            var self = this;
            this._contentsListRetryTimer = setTimeout(function () {
                self._requestContentList($target);
            }, (this._retryCount * retryInterval));
        } catch (e) {
            this._finishContentsListRetry();
        }
    },
    /**
     * 공감하기 count 컨텐츠 대상 설정
     * @param $target
     * @private
     */
    _setTargetContentsList: function ($target) {
        this._$targetContentsList = $target;
    },
    /**
     * 공감하기 count 컨텐츠 대상 삭제
     * @private
     */
    _clearTargetContentsList: function () {
        this._$targetContentsList = null;
    },
    /**
     * 공감하기 count를 요청한다.
     *
     * @private
     * @param {jQuery} $target count를 가져올 공감하기 jQuery 객체
     */
    _requestContentList: function ($target) {
        var requestQueue = this._getRequestQueue($target),
            fallback = jQuery.proxy(function () {
                this._contentsListRetry($target);
            }, this),
            callback = jQuery.proxy(function (res) {
                if (!res.errorCode) {
                    this._isLogin = res.isLogin;
                    this._serviceOptionType = Object.assign(res.serviceOptionType, this._serviceOptionType);

                    //버튼 UI 생성 및 초기화
                    this._drawButtons($target, this._convertToMapData(res.contents));

                    //비로그인 토큰값 저장
                    reaction._guestToken = res.guestToken || "";
                    reaction._timestamp = res.timestamp || "";

                    //공감하기 카운트 초기화 실행(update 실행시)
                    this._conf.callback && this._conf.callback.updated && this._conf.callback.updated({
                        targets: $target.get(),
                        contents: res.contents
                    });
                    this._triggerParentCallback(res);

                    //css로드
                    var cssConfs = res.cssConfs;
                    if (cssConfs != null) {
                        for (var i = 0; i < cssConfs.length; i++) {
                            var serviceId = cssConfs[i].cssId.replace("_PC", "").replace("_MOBILE", "");

                            if (cssConfs[i].staticId != null) {
                                var url = this._isDeveloperServer() ? this._resources.css.cssStaticUrl.dev : this._resources.css.cssStaticUrl.real;
                                url = url
                                    .replace("{cssId}", serviceId)
                                    .replace("{assignId}", cssConfs[i].assignId)
                                    .replace("{staticId}", cssConfs[i].staticId)
                                    .replace("{file}", serviceId);

                                this._isExistResource(url) ? this._loadCssFile(url) : this._loadSourceCss(serviceId);
                            } else {  //TODO: 추후 삭제예정(기존css 호출)
                                this._loadSourceCss(serviceId);
                            }
                        }
                    } else {  //TODO: 추후 삭제예정(기존css 호출)
                        this._loadSourceCss(null);
                    }
                }
            }, this);

        //domain 갯수 만큼 카운트 목록 요청
        for (var i = 0, data, parent, nLen = requestQueue.length; i < nLen; i++) {
            data = {
                q: this._convertToParamString(requestQueue[i].services, "contentIds"),
                isDuplication: requestQueue[i].duplication,
                cssIds: this._makeCssIdList(this._conf.cssId)
            };

            //blog는 api g/w&pool=blogid -> blog g/w -> api g/w&pool=blog -> route nfront -> n3r에서 pool=blog로 backend 분기
            if (typeof this._displayId === "string" && this._displayId.trim() !== "") {
                //displayId는 search api에서는 초기화때 서비스에서 넣어주어야 사용 가능함. 좋아요에서 임의의 값을 넣어줄 수 없음(알수없음)
                data.displayId = this._displayId;
            } else if (!this._isUseApigw && !this._isNeoid && !!this._routePool) { //_isUseApigw나 _isNeoid는 this._resources.content에 pool이 포함되어 있음
                data.pool = this._routePool;
            }

            parent = this._convertToParamString(requestQueue[i].services, "parentIds");
            parent && (data.pq = parent);
            jQuery.ajax({
                url: this._isNeoid || this._isUseApigw ? this._resources.content : requestQueue[i].domain + this._resources.content,
                dataType: "jsonp",
                scriptCharset: "utf-8",
                timeout: this._requestReactionTimeout,
                data: data,
                context: this,
                success: callback,
                error: fallback
            });
        }
    },

    _makeCssIdList: function (cssId) {
        var cssIdList = [];
        var suffix = this._conf.isMobile ? "_MOBILE" : "_PC";

        //cssId를 지정한 경우에만 css를 받도록 함.
        if (!!cssId) {
            if (this._conf.previewCssUrl) {
                cssIdList.push(/face|multi/.test(this._conf.type) ? "MULTI" + suffix : "BASIC" + suffix);
                this._loadCssFile(this._conf.previewCssUrl);
            } else {
                cssIdList.push(/face|multi/.test(this._conf.type) ? "MULTI" + suffix : "BASIC" + suffix);
                var cssIds = cssId.split(",");

                for (var i = 0; i < cssIds.length; i++) {
                    cssIdList.push(cssIds[i].toUpperCase() + suffix);
                }
            }
        }
        return cssIdList.join(",");
    },

    _loadCssFile: function (url) {
        var headElement = document.head || document.getElementsByTagName("head")[0],
            createdElement = document.createElement("link"),
            isFullUrl = /^(http|https)/.test(url),
            staticUrl = isFullUrl ? url : (this._conf.staticDomain || this._apiDomain) + url,
            isHttps = isFullUrl ? /^(https)/.test(url) : /^(https)/.test(this._apiDomain);

        createdElement.type = "text/css";
        createdElement.rel = "stylesheet";
        createdElement.className = "like_css";
        createdElement.href = isHttps ? staticUrl.replace("/css/reaction/", "/css/ssl/reaction/") : staticUrl;

        headElement.appendChild(createdElement);

        var link_length = document.getElementsByClassName("like_css").length;
        document.getElementsByClassName("like_css").item(link_length - 1).onload = function () {
            jQuery("._reactionModule").css("visibility", "visible");
        };
    },

    _isDeveloperServer: function () {
        if (/(local\.|local\-|dev\.|dev\-|test\.|test\-|stage\.)/.test(this._conf.domain)) {
            return true;
        }
        return false;
    },

    _finishLoadRetry: function () {
        clearTimeout(this._loadRetryTimer);
        this._isLoadRetryFinish = true;
    },

    _retryLoadResource: function ($target) {
        try {
            var retryLimit = 3,
                retryInterval = 7000;

            if (this._isLoadRetryFinish) {
                return;
            }

            if (this._cssLaodRetryCount >= retryLimit) {
                this._finishLoadRetry();
                return;
            }
            this._cssLaodRetryCount = this._cssLaodRetryCount + 1;

            var self = this;
            this._loadRetryTimer = setTimeout(function () {
                self._isExistResource($target);
            }, (this._cssLaodRetryCount * retryInterval));
        } catch (e) {
            this._finishLoadRetry();
        }
    },

    _isExistResource: function (url) {
        var result;
        jQuery.ajax({
            url: url,
            async: false,
            context: this,
            success: function () {
                result = true;
            },
            error: function () {
                this._retryLoadResource(url);
                result = false;
            }
        });
        return result;
    },

    //TODO: 추후 삭제예정(기존css 호출)
    _loadSourceCss: function (serviceId) {
        if (serviceId == null) {
            this._loadCssFile(this._getCssUrl(/face|multi/.test(this._conf.type) ? this._resources.css.common_multi : this._resources.css.common_basic));
            if (!!this._conf.cssId) {
                var cssIds = this._conf.cssId.split(",");
                for (var i = 0; i < cssIds.length; i++) {
                    this._loadCssFile(this._getCssUrl(this._resources.css.service.replace("{cssId}", cssIds[i].toLowerCase())));
                }
            }
        } else {
            if (/basic|multi/.test(serviceId.toLowerCase())) {
                this._loadCssFile(this._getCssUrl(/face|multi/.test(this._conf.type) ? this._resources.css.common_multi : this._resources.css.common_basic));
            } else {
                this._loadCssFile(this._getCssUrl(this._resources.css.service.replace("{cssId}", serviceId.toLowerCase())));
            }
        }
    },

    //TODO: 추후 삭제예정(기존css 호출)
    _getCssUrl: function (url, isMobile) {
        var cssUrl = "";
        var buildString = "/staticBuildNumber";

        if (isMobile != null) {
            cssUrl = (this._conf.isDebugMode ? "" : buildString) + (isMobile ? url : url.replace("/mobile/", "/desktop/"));
        } else {
            cssUrl = (this._conf.isDebugMode ? "" : buildString) + (this._conf.isMobile ? url : url.replace("/mobile/", "/desktop/"));
        }
        return cssUrl;
    },

    /**
     * 저정한 영역내에서 버튼을 찾아 생성 및 초기화한다.
     *
     * @private
     * @param {jQuery} $target 생성 및 초기화할 영역을 래핑한 jQuery 객체
     * @param {Object} 초기화시 사용할 데이터셋
     */
    _drawButtons: function ($target, contents) {
        var self = this;
        $target.each(function (i, base) {
            var $base = jQuery(base),
                reactionDataSet = contents[$base.attr("data-sid") + "_" + $base.attr("data-cid")],
                isCustomizedText = contents[$base.attr("data-sid") + "_customized"],
                isDifferentPlatForm = contents[$base.attr("data-sid") + "_differentPlatform"];

            self._reactionTextMap = !!contents[$base.attr("data-sid") + "_reactionTextMap"] ? contents[$base.attr("data-sid") + "_reactionTextMap"][self._conf.language.replace("_", "-")] : null;

            if (reactionDataSet) {
                $base.find("._button").each(function (i, button) {
                    var $button = jQuery(button),
                        reactionType = $button.attr("data-type"),
                        reactionData = reactionDataSet[reactionType] || {},
                        labelType = $button.attr("data-viewtype") || reactionType,
                        replaceLabel = self._reactionTextMap[labelType];

                    // pc, m 각각 감성 텍스트가 다른 서비스일 경우
                    if (isDifferentPlatForm) {
                        replaceLabel = self._conf.isMobile ? replaceLabel.m : replaceLabel.pc;
                    }

                    //처음 생성되는 버튼이고, 버튼 내부 마크업이 없으면 템플릿으로 생성
                    if (self._isDrawingByTemplate($base, $button)) {
                        $button.html(self._conf.buttonTemplate.replace("{label}", self._reactionTextMap[labelType]));
                    } //처음 생성되는 버튼일 경우, 버튼 감성 텍스트 스크립트로 생성
                    else if (!isCustomizedText && self._isEmptyButton($base, $button)) {
                        $button.find("._label").html(replaceLabel);
                    }

                    //버튼 갱신 (from server)
                    self._updateButton($base, $button, reactionData.isReacted, reactionData.count);
                });

                $base.find("._nolimitButton").each(function (i, button) {
                    var $button = jQuery(button),
                        reactionType = $button.attr("data-type"),
                        reactionData = reactionDataSet[reactionType] || {},
                        labelType = $button.attr("data-viewtype") || reactionType,
                        replaceLabel = self._reactionTextMap[labelType];

                    // pc, m 각각 감성 텍스트가 다른 서비스일 경우
                    if (isDifferentPlatForm) {
                        replaceLabel = self._conf.isMobile ? replaceLabel.m : replaceLabel.pc;
                    }

                    //처음 생성되는 버튼이고, 버튼 내부 마크업이 없으면 템플릿으로 생성
                    if (self._isDrawingByTemplate($base, $button)) {
                        $button.html(self._conf.buttonTemplate.replace("{label}", self._reactionTextMap[labelType]));
                    } //처음 생성되는 버튼일 경우, 버튼 감성 텍스트 스크립트로 생성
                    else if (!isCustomizedText && self._isEmptyButton($base, $button)) {
                        $button.find("._label").html(replaceLabel);
                    }

                    //버튼 갱신 (from server)
                    self._updateButton($base, $button, reactionData.isReacted, reactionData.count);
                });

                self._drawFaceButtons($base, reactionDataSet);

                // 버튼셋이 초기화 완료 되었음을 기준 엘리먼트에 기록
                $base.attr("data-loaded", "1");

                var $faceLayer = $base.find("._faceLayer");

                //감성 레이어 열기 옵션이 true인 경우 show
                if ($base.attr("data-isOpenFaceLayer") === "true") {
                    $base.find("._faceLayer").show();
                }

                // face타입 여부를 저장
                $base.attr("data-facetype", $faceLayer.length);
            }
        });
    },

    /**
     * 버튼 아이콘에 표현할 데이터를 세팅한다.
     * reactionDataSet에는 감성 타입별 공감 내역이 있고 markUserReaction(사용자가 공감한 타입을 표시하는 옵션)에 따라
     * 사용자가 공감한 내역만 추출 또는 전체 데이터를 추출한다.
     * markUserReaction가 true이면 사용자가 공감한 데이터가 있으면 버튼 아이콘에 표시하고, false이면 좋아요 기본 옵션인 모든 공감 데이터를 대상으로 버튼 아이콘을 표시한다.
     * @param $base
     * @param reactionDataSet
     * @returns {Array}
     * @private
     */
    _getCounts: function ($base, reactionDataSet) {
        var counts = [];
        if ($base.attr("data-markUserReaction")) {
            for (var data in reactionDataSet) {
                if (reactionDataSet[data].isReacted) {
                    counts.push({
                        type: data,
                        count: reactionDataSet[data].count,
                        isReacted: reactionDataSet[data].isReacted
                    });
                }
            }
        } else {
            for (var p in reactionDataSet) {
                counts.push({
                    type: p,
                    count: reactionDataSet[p].count,
                    isReacted: reactionDataSet[p].isReacted
                });
            }
        }
        return counts;
    },

    _drawFaceButtons: function ($base, reactionDataSet) {
        var $faceButton = $base.find("._face").first();
        if (!$faceButton.length) {
            return;
        }

        var isReacted = false;
        var totalCount = 0;

        // client 쪽에서 isReacted 상태와 count 상태를 확인 (클라이언트에서 처리하도록 정리)
        for (var p in reactionDataSet) {
            if (reactionDataSet[p].isReacted) {
                isReacted = true;
            }
            totalCount += reactionDataSet[p].count;
        }

        var counts = this._getCounts($base, reactionDataSet);

        //처음 생성되는 버튼이고, 버튼 내부 마크업이 없으면 템플릿으로 생성
        if (this._isDrawingByTemplate($base, $faceButton)) {
            var title = $faceButton.attr("data-label") || "default";
            $faceButton.html(this._conf.faceButtonTemplate.replace("{label}", this._messages.face[title]));
        }

        // face버튼의 아이콘을 만든다.
        this._makeFaceIcons($base, $faceButton);

        //버튼 갱신 (from server)
        this._updateFaceButton($faceButton, isReacted, counts, totalCount, $base.attr("data-markUserReaction"));

        //layer release 버튼에 nlog 추가
        var serviceId = $base.attr("data-sid");
        if (this._isSendNlog(serviceId)) {
            if (this._conf.callback.clickFaceButtonText) {
                $faceButton.removeAttr("data-like-click-area");
                $base.find("a._face ._count").attr("data-like-click-area", "count.release");
                $base.find("a._face ._icons").attr("data-like-click-area", "face.release");
            } else {
                $faceButton.attr("data-like-click-area", "face.release");
            }
        }
    },

    /**
     * facebutton의 내부 아이콘용 makeup을 생성한다.
     *
     * @private
     * @param {jQuery} $base 모듈 최상위 엘리먼트를 래핑한 jQuery 객체
     * @param {jQuery} $button 버튼 엘리먼트를 래핑한 jQuery 객체
     */
    _makeFaceIcons: function ($base, $button) {
        var max = $base.attr("data-faceButtonMaxIconCount") || this._conf.faceButtonMaxIconCount;
        if (max <= 0) {
            return;
        }
        if ($base.attr("data-loaded") !== "1") {
            var $icons = $button.find("._icons").first();
            var $children = $icons.children();
            var diff = max - $children.length;
            if (diff > 0) { // append
                var $icon = $children.first();
                for (var i = 0; i < diff; i++) {
                    $icon.clone().hide().appendTo($icons);
                }
            } else if (diff < 0) {	// remove
                jQuery($children.splice(max)).each(function (i, v) {
                    jQuery(v).remove();
                });
            }
        }
    },

    /**
     * 처음생성되는 버튼인지 여부를 반환
     * @param {jQuery} $base 모듈 최상위 엘리먼트를 래핑한 jQuery 객체
     * @return {Boolean} 처음생성 되는 버튼인지 여부(true: 처음생성 됨, false: 이미 생성되어 있음)
     * */
    _isEmptyButton: function ($base) {
        return $base.attr("data-loaded") !== "1";
    },

    /**
     * 내부 템플릿으로 덮어쓸지 여부를 반환한다.
     *
     * @private
     * @param {jQuery} $base 모듈 최상위 엘리먼트를 래핑한 jQuery 객체
     * @param {jQuery} $button 버튼 엘리먼트를 래핑한 jQuery 객체
     * @return {Boolean} 내부 템플릿으로 덮어쓸지 여부(true: 덮어씀, false: 덮어쓰지 않음)
     */
    _isDrawingByTemplate: function ($base, $button) {
        //처음 생성되는 버튼이고, 템플릿으로 강제 덮어쓰기 또는, 버튼 내부 마크업이 없으면 템플릿으로 생성.
        //서비스에서 class 등을 추가 지정할 수 있으므로 서비스에서 tag를 추가하되 lable은 좋아요에서 관리.
        return $base.attr("data-loaded") !== "1" && !jQuery.trim($button.html());
    },

    /**
     * 지정한 버튼을 갱신한다.
     *
     * @private
     * @param {jQuery} $button 버튼 엘리먼트를 래핑한 jQuery 객체
     * @param {Boolean} [isReacted] 버튼 선택 여부
     * @param {Number} [count] face 버튼에 표기될 숫자
     */
    _updateButton: function ($base, $button, isReacted, count) {
        if (!$button.length) {
            return;
        }
        var visibleOptionOfButton = this._getVisibleOptionOfButton($button);
        this._updateClassButton($button, isReacted, this._isFace($base) || this._isNolimit($base) ? "aria-selected" : "aria-pressed", $base.attr("data-sid"));
        this._updateIconInButton($button, isReacted, visibleOptionOfButton);
        this._updateLabelInButton($button, count, visibleOptionOfButton);
        this._updateCountInButton($button, count, visibleOptionOfButton);
        this._updateHighlightButton($base, $button, count);
    },

    /**
     * 지정한 표정(FACE) 버튼을 갱신한다.
     *
     * @private
     * @param {jQuery} $button face 버튼 엘리먼트를 래핑한 jQuery 객체
     * @param {Boolean} [isReacted] 버튼 선택 여부
     * @param {Array} [counts] face 상세 내역들
     * @param {Number} [totalCount] face 버튼에 표기될 숫자
     * @param {Boolean} [isMarkUserReaction] 사용자가 공감한 타입을 표시해줄건지 여부
     */
    _updateFaceButton: function ($button, isReacted, counts, totalCount, isMarkUserReaction) {
        if (!$button.length) {
            return;
        }
        counts = counts || [];
        var $count;

        // $button안 입력한 경우 (클라이언트에서 숫자를 맞춤)
        if (typeof isReacted === "undefined" && Array.isArray(counts) && counts.length === 0) {
            isReacted = ($button.parent().find("._button." + this._conf.iconToggleClassname[0]).length > 0);
            totalCount = 0;
            var self = this;
            var num = 0;

            //기본 계산 영역 분리
            $button.parent().find("._button ._count").each(function (i, v) {
                $count = jQuery(v);
                num = self._toNum($count.text());
                totalCount += num;
            });

            //counts 계산 영역
            $button.parent().find("._button ._count").each(function (i, v) {
                $count = jQuery(v);
                var btnType = $count.parent().attr("data-type");
                num = self._toNum($count.text());
                var btnReacted = $count.closest("a._button").is(".on");
                if (isMarkUserReaction) {
                    if (isReacted) {
                        counts.push({
                            type: btnType,
                            count: num,
                            isReacted: btnReacted
                        });
                    }
                } else {
                    counts.push({
                        type: btnType,
                        count: num,
                        isReacted: btnReacted
                    });
                }
            });
        }

        // 필터링과 sorting
        counts = jQuery.grep(counts, function (v) {
            if (isMarkUserReaction) {
                return v.isReacted;
            }
            return v.count !== 0;
        }).sort(function (p, n) {
            if (p.count === n.count) {
                // 동일한 경우에는 like가 우선
                if (p.type === "like") {
                    return -1;
                } else if (n.type === "like") {
                    return 1;
                }
                return 0;
            } else {
                return n.count - p.count;
            }
        });

        var title = $button.attr("data-label") || "default";
        $count = this._getCountButton($button);
        if (totalCount) {
            $count.html(this._formattedCount(totalCount, $button.attr("data-maxcount")))
                .addClass("num");
        } else {
            $count.html(this._messages.face[title])
                .removeClass("num");
        }
        var $base = $button.closest("." + this._conf.moduleClassname).first();
        this._updateFaceButtonIcons($base, $button, counts);	// icon 배열 처리
        this._updateClassButton($button, isReacted, this._isNolimit($base) ? "aria-selected" : "aria-pressed", $base.attr("data-sid"));
    },

    /* 표정 버튼 내의 아이콘을 update한다 */
    _updateFaceButtonIcons: function ($base, $facebutton, counts) {
        var $icons = $facebutton.find("._icons").first();
        if (!$icons.length) {
            return;
        }
        var $children = $icons.children();
        var $el;
        var type;

        for (var i = 0, len = $base.attr("data-faceButtonMaxIconCount") || this._conf.faceButtonMaxIconCount, dataLen = counts.length; i < len; i++) {
            if (dataLen > i) {
                $el = $children.eq(i).show();
                type = counts[i].type;
                this._updateIconsByType($el, type);
                $el.css("zIndex", len - i + 1)
                    .find("span").html(this._reactionTextMap[type]);
            } else {
                if (i === 0) {
                    if (dataLen === 0) {	// count가 아무것도 업는 경우.
                        this._conf.isZeroFace ? this._updateIconsByType($children.eq(i), "zeroface") : this._updateIconsByType($children.eq(i), "like");
                    }
                } else {
                    $children.eq(i).hide();
                }
            }
        }
    },

    // 표정 타입을 클래스에 반영
    _updateIconsByType: function ($el, type) {
        var el = $el.get(0);
        var classes = el.className.split(" ");
        el.className = jQuery.grep(classes, function (v) {
            return !/^__reaction__/.test(v);
        }).join(" ") + " __reaction__" + type;
    },

    /**
     * 지정한 버튼 내 공감 카운트를 갱신한다.
     *
     * @private
     * @param {jquery} $button 버튼 엘리먼트를 래핑한 jQuery 객체
     * @param {Number} count 공감 누적 수
     * @param {Object} visibleOptionOfButton 버튼 내부 요소들의 노출 여부를 가진 객체
     */
    _updateCountInButton: function ($button, count, visibleOptionOfButton) {
        var $count = this._getCountButton($button),
            reactionCount = count || 0,
            isShown = !(visibleOptionOfButton.isHiddenCount || (reactionCount === 0 && (visibleOptionOfButton.isHiddenZeroCount || visibleOptionOfButton.isUsedLabelAsZeroCount)));
        $count.length && $count.html(this._formattedCount(reactionCount, $button.attr("data-maxcount"))).toggle(isShown);
    },

    /**
     * 아이콘 강조 효과 처리
     *
     * @private
     * @param {jquery} $button 버튼 엘리먼트를 래핑한 jQuery 객체
     * @param {Number} count 공감 누적 수
     */
    _updateHighlightButton: function ($base, $button, count) {
        if (!this._serviceOptionType || !this._serviceOptionType[$base.attr("data-sid")] || !this._serviceOptionType[$base.attr("data-sid")]["012"]) {
            return;
        }

        if (this._isFace($base)) {
            return;
        }

        if (!this._conf.highlightCount || this._conf.highlightCount < 1) {
            return;
        }

        if (!count) {
            return;
        }

        var highlightClassname = this._conf.highlightClassname || "";

        if (count < this._conf.highlightCount) {
            $button.removeClass(highlightClassname);
        } else {
            $button.addClass(highlightClassname);
        }
    },

    /**
     * 숫자 포맷을 맞춰주는 함수
     *
     * @private
     * @param {Number} count 숫자
     * @param {Number} max 표기할 최대 숫자
     */
    _formattedCount: function (count, max) {
        var minCount = 0,
            maxCount = max || this._conf.maxCount,
            sourceCount = Math.max(minCount, Math.min(count, maxCount)).toString(),
            formatted = sourceCount.replace(/(\d)(?=(\d{3})+$)/igm, "$1,"), //3자리 콤마찍기
            moreSymbol = (count >= maxCount) ? "+" : "";
        return formatted + moreSymbol;
    },

    /**
     * global 옵션과 엘리먼트에 직접 할당된 local 옵션간의 우선순위를 결정하여 반환한다.(local 옵션 우선)
     *
     * @private
     * @param {jQuery} $element 엘리먼트를 래핑한 jQuery 객체
     * @param {String} optionName 옵션 이름
     * @return {Boolean} 우선순위에 의해 결정된 옵션의 값
     */
    _getValueOfPrioritizedOption: function ($element, optionName) {
        var globalOptionValue = this._conf[optionName],
            localOptionValue = $element.attr("data-" + optionName),
            applyingOptionValue = globalOptionValue;

        //localOption은 무조건 문자열이겠지만...혹시 몰라서 체크함..
        if (localOptionValue !== undefined && localOptionValue !== null) {
            applyingOptionValue = (typeof localOptionValue === "boolean" && !!localOptionValue) || (localOptionValue === "true") || !!(parseInt(localOptionValue, 10));
        }

        return applyingOptionValue;
    },

    /**
     * global-option과 Button의 inline-option
     *
     * @private
     * @param  {jQuery} $button 버튼 엘리먼트를 래핑한 jQuery 객체
     * @return {Object} 버튼 내부 요소들의 노출 여부를 가진 객체
     * @example
     * return => {
     *      isHiddenIcon: false,
     *      isHiddenLabel: false,
     *      isHiddenCount: false,
     *      isHiddenZeroCount: false,
     *      isUsedLabelAsZeroCount: false,
     *      isHiddenLabelAsZeroCount: false
     * }
     */
    _getVisibleOptionOfButton: function ($button) {
        return {
            isHiddenIcon: this._getValueOfPrioritizedOption($button, "isHiddenIcon"),
            isHiddenLabel: this._getValueOfPrioritizedOption($button, "isHiddenLabel"),
            isHiddenCount: this._getValueOfPrioritizedOption($button, "isHiddenCount"),
            isHiddenZeroCount: this._getValueOfPrioritizedOption($button, "isHiddenZeroCount"),
            isUsedLabelAsZeroCount: this._getValueOfPrioritizedOption($button, "isUsedLabelAsZeroCount"),
            isHiddenLabelAsZeroCount: this._getValueOfPrioritizedOption($button, "isHiddenLabelAsZeroCount")
        };
    },

    /**
     * 지정한 버튼 내 아이콘을 갱신한다.
     *
     * @private
     * @param {jQuery} $button 버튼 엘리먼트를 래핑한 jQuery 객체
     * @param {Boolean} isReacted 공감 여부(true: 공감, false: 취소)
     * @param {Object} visibleOptionOfButton 버튼 내부 요소들의 노출 여부를 가진 객체
     */
    _updateIconInButton: function ($button, isReacted, visibleOptionOfButton) {
        var $icon = $button.find("._icon"),
            isShown = !visibleOptionOfButton.isHiddenIcon;

        $icon.length && $icon.toggle(isShown);
    },

    _updateClassButton: function ($button, isReacted, accessibility, serviceId) {
        var toggleClassname = this._conf.iconToggleClassname,
            onClassname = toggleClassname[0] || "",
            offClassname = toggleClassname[1] || "",
            parents = $button.parents(),
            reactType = $button.attr("data-type"),
            countType = "normal",
            clickType = isReacted ? "un" : "";

        for (var i = 0; i < parents.length; i++) {
            var count,
                p = jQuery(parents[i]);

            count = p.attr("data-ccounttype");
            if (count !== undefined) {
                countType = count;
                if (count === "nolimit") {
                    clickType = "";
                }
                break;
            }
        }

        if (this._isSendNlog(serviceId) && !$button.hasClass("_face")) {
            $button.attr("data-like-click-area", countType + "." + clickType + reactType);
        }

        if (isReacted) {
            $button.addClass(onClassname).removeClass(offClassname).attr(accessibility, "true");
        } else {
            $button.addClass(offClassname).removeClass(onClassname).attr(accessibility, "false");
        }
    },

    /**
     * 지정한 버튼 내 라벨을 상태를 갱신한다.
     *
     * @private
     * @param {jquery} $button 버튼 엘리먼트를 래핑한 jQuery 객체
     * @param {Number} count 공감 누적 수
     * @param {Object} visibleOptionOfButton 버튼 내부 요소들의 노출 여부를 가진 객체
     */
    _updateLabelInButton: function ($button, count, visibleOptionOfButton) {
        var reactionCount = count || 0,
            $label = $button.find("._label"),
            isShown = true;

        if (visibleOptionOfButton.isHiddenLabel) {
            isShown = false;
        } else {
            var isZeroReaction = reactionCount === 0;

            if (visibleOptionOfButton.isUsedLabelAsZeroCount) {
                isShown = isZeroReaction;
            } else if (visibleOptionOfButton.isHiddenLabelAsZeroCount) {
                isShown = !isZeroReaction;
            }
        }
        $label.length && $label.toggle(isShown);
    },

    /**
     * 지정한 공감하기 버튼셋을 갱신한다.
     *
     * @private
     * @param {jQuery} $target 갱신할 버튼셋
     */
    _update: function ($target) {
        var totalCount = $target.length,
            contentCountPerOnceRequest = this._conf.contentCountPerOnceRequest,
            requestCount = Math.ceil(totalCount / contentCountPerOnceRequest),
            i, startIndex, endIndex;
        if (!totalCount) {
            return;
        }

        //한번에 조회할 컨텐츠의 갯수 설정에 따른 API 요청 분리
        for (i = 0; i < requestCount; i++) {
            startIndex = Math.max(0, i * contentCountPerOnceRequest);
            endIndex = Math.min(startIndex + contentCountPerOnceRequest, totalCount);

            this._requestContentList($target.slice(startIndex, endIndex));
        }
    },

    /**
     * 공감하기 버튼셋을 탐색하여 반환한다.
     *
     * @private
     * @param {Selector|jQuery|HTMLElement[]|HTMLElement} [context=document.body] 갱신할 버튼 엘리먼트 배열 or 갱신할 버튼을 감싸고 있는 상위 엘리먼트
     * @param {Boolean} [isAllRefresh=false] 이전에 갱신한 버튼을 다시 갱신할지 여부
     * @param {Boolean} [pollingNolimit=true] 무한공감 자동갱신 요청인 경우 무한공감 엘리먼트만 업데이트할지 여부.
     * @return {jQuery} 탐색된 버튼셋을 래핑한 jQuery 객체
     */
    _getFilteredTarget: function (context, isAllRefresh, pollingNolimit) {
        var $target = jQuery();

        if (!context) { /* 문서 전체(document) 탐색 */
            $target = $target.add("." + this._conf.moduleClassname);
        } else { /* context 하위 탐색 */
            jQuery(context).each(jQuery.proxy(function (i, target) {
                if (jQuery(target).hasClass(this._conf.moduleClassname)) {
                    $target = $target.add(target);
                } else {
                    $target = $target.add("." + this._conf.moduleClassname, target);
                }
            }, this));
        }

        if (pollingNolimit) {
            $target = $target.filter("[data-ccounttype='nolimit']");
        }

        //전체 갱신(isAllRefresh=true)이 아니면 이전에 로드된 버튼을 제외함.
        if (!isAllRefresh) {
            $target = $target.filter("[data-loaded!='1']");
        }
        return $target;
    },

    /**
     * 공감하기 버튼셋을 탐색하여 갱신한다.
     *
     * @param {Selector|jQuery|HTMLElement[]|HTMLElement} [context=document.body] 갱신할 버튼 엘리먼트 배열 or 갱신할 버튼을 감싸고 있는 상위 엘리먼트
     * @param {Boolean} [isAllRefresh=false] 이전에 갱신한 버튼을 다시 갱신할지 여부
     * @param {Boolean} [pollingNolimit=true] 무한공감 자동갱신 요청인 경우 무한공감 엘리먼트만 업데이트할지 여부.
     */
    update: function (context, isAllRefresh, pollingNolimit) {
        this._update(this._getFilteredTarget(context, isAllRefresh, pollingNolimit));
    },

    /**
     * 공감하기 수치(+1)를 증가시킨다
     *
     * @param {HTMLElement} buttonElement 공감하기 기준 엘리먼트
     */
    increase: function (buttonElement) {
        this._requestReaction(buttonElement, true);
    },

    /**
     * 무한 공감하기 수치(+n)를 증가시킨다
     *
     * count : 5
     * history : 1499672970927|1499672971110|1499672971295|1499672971463|1499672971640
     *
     * @param {HTMLElement} buttonElement 공감하기 기준 엘리먼트
     */
    increaseNolimit: function (buttonElement) {
        var history = [];
        if (this._nolimitHistory.length < this._maxLimitCount) {
            history.push(new Date().getTime());
            this._conf.runtime() && history.push(this._conf.runtime());
            this._nolimitHistory.push(history.join(","));
        }

        this._increseNolimitCount(buttonElement);

        if (!this._wait) {
            this._wait = true;

            this._nolimitTimer = setTimeout(jQuery.proxy(function () {
                clearInterval(this._nolimitPolling);
                this._requestReaction(buttonElement, true);
            }, this), 1000);
        }
    },

    /**
     * 공감 서버 보내기 전까지 카운트가 올라가는 효과를 주기 위해 추가.
     */
    _increseNolimitCount: function (buttonElement) {
        var $target = jQuery(buttonElement),
            $buttons = jQuery().add($target),
            isAdding = true,
            count = 1;

        this._updateReactionFromClient($buttons, isAdding, undefined, count, false);
    },

    /**
     * 무한공감하기 자동 갱신.
     * 무한공감 엘리먼트만 선별하여 갱신해준다.
     */
    _pollingNolimit: function () {
        if (!this._conf.isUseNolimitCountPolling) {
            return;
        }

        clearInterval(this._nolimitPolling);
        var pollingTime = (this._conf.nolimitCountPollingTime < 10 ? 10 : this._conf.nolimitCountPollingTime) * 1000; //milliseconds로 변환
        this._nolimitPolling = setInterval(jQuery.proxy(function () {
            this.update(undefined, true, true);
        }, this), pollingTime);
    },

    /**
     * 공감하기 수치(+1)를 감소시킨다
     *
     * @param {HTMLElement} buttonElement 공감하기 기준 엘리먼트
     */
    decrease: function (buttonElement) {
        this._requestReaction(buttonElement, false);
    },

    _isFace: function ($base) {
        return $base.attr("data-facetype") === "1";
    },

    _isNolimit: function ($base) {
        return $base.attr("data-ccounttype") === "nolimit";
    },

    _toNum: function (str) {
        if (!str) {
            return 0;
        }
        return Number(str.replace(/[^-\.\d]/g, ""));
    },

    _destroy: function () {
        this._detachEvent();
    },

    hideLayers: function () {
        this._hideLayers();
    },

    // nlog 전송 여부 확인
    _isSendNlog: function (serviceId) {
        return this._conf.forceSendNlog ||
            (this._serviceOptionType && this._serviceOptionType[serviceId] && this._serviceOptionType[serviceId]["026"]);
    }
};

